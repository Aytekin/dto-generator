using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using DtoGenerator.Logic.Infrastructure;
using DtoGenerator.Logic.Model;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.MSBuild;

namespace DtoGenerator.Logic.UI
{
    public class PropertySelectorViewModel : ViewModelBase
    {
        public static async Task<PropertySelectorViewModel> Create(Document doc, string dtoName, SolutionLocation dtoLocation, Document existingDto = null)
        {
            var autogeneratedProperties = await EntityParser.GetAutoGeneratedProperties(existingDto);

            var instance = new PropertySelectorViewModel();

            instance.EntityModel = await EntityViewModel.CreateRecursive(doc, depth: 3, existingProperties: autogeneratedProperties);
            instance.EntityModel.DtoName = dtoName;
            instance.DtoLocation = dtoLocation;

            return instance;
        }

        private PropertySelectorViewModel()
        {

        }
        
        public SolutionLocation DtoLocation { get; set; }

        private EntityViewModel _entityModel;
        public EntityViewModel EntityModel
        {
            get
            {
                return this._entityModel;
            }
            set
            {
                if (value != this._entityModel)
                {
                    this._entityModel = value;
                    this.InvokePropertyChanged(nameof(EntityModel));
                }
            }
        }

        public EntityMetadata GetMetadata()
        {
            if (this._entityModel != null)
                return this._entityModel.ConvertToMetadata();

            return null;
        }
    }

    public class EntityViewModel : ViewModelBase
    {
        private EntityMetadata _originalMetadata;

        public string EntityName { get; set; }
        public string DtoName { get; set; }

        private bool _includeBaseEntity;
        public bool IncludeBaseEntity
        {
            get
            {
                return this._includeBaseEntity;
            }
            set
            {
                if (value != this._includeBaseEntity)
                {
                    this._includeBaseEntity = value;
                    this.InvokePropertyChanged(nameof(IncludeBaseEntity));
                }
            }
        }

        private string _baseEntityDtoName;
        public string BaseEntityDtoName
        {
            get
            {
                return this._baseEntityDtoName;
            }
            set
            {
                if (value != this._baseEntityDtoName)
                {
                    this._baseEntityDtoName = value;
                    this.InvokePropertyChanged(nameof(BaseEntityDtoName));
                }
            }
        }

        public ObservableCollection<PropertyViewModel> Properties { get; set; }

        public static async Task<EntityViewModel> CreateRecursive(Document doc, int depth = 3, bool autoSelect = true, bool canSelectCollections = true, bool includeInherited = false, List<string> existingProperties = null)
        {
            var instance = new EntityViewModel();

            instance.Properties = new ObservableCollection<PropertyViewModel>();

            instance._originalMetadata = await EntityParser.FromDocument(doc, includeInherited: includeInherited);
            instance.EntityName = instance._originalMetadata.Name;

            foreach (var p in instance._originalMetadata.Properties)
            {
                var propViewModel = new PropertyViewModel(instance);
                propViewModel.Name = p.Name;
                propViewModel.Type = p.Type;
                propViewModel.CanSelect = true;

                if (p.IsCollection && !canSelectCollections)
                    propViewModel.CanSelect = false;

                propViewModel.IsSelected = autoSelect && p.IsSimpleProperty;

                if(existingProperties != null)
                    propViewModel.IsSelected = propViewModel.CanSelect && existingProperties.Any(x => x == p.Name);

                if (p.IsRelation && !p.IsCollection && depth > 0)
                {
                    var relatedDoc = await doc.GetRelatedEntityDocument(p.RelatedEntityName);
                    if(relatedDoc != null)
                    {
                        var relatedProperties = existingProperties == null 
                            ? null 
                            : existingProperties.Where(x => x.StartsWith(p.Name))
                                .Select(x => x.Substring(p.Name.Length))
                                .ToList();

                        propViewModel.RelatedEntity = await CreateRecursive(relatedDoc, depth: depth - 1, autoSelect: false, canSelectCollections: false, includeInherited: true, existingProperties: relatedProperties);
                    }
                    else
                    {
                        p.IsRelation = false;
                        p.IsSimpleProperty = true;
                    }
                }

                instance.Properties.Add(propViewModel);
            }

            return instance;
        }

        private EntityViewModel()
        {

        }

        public EntityMetadata ConvertToMetadata()
        {
            var result = this._originalMetadata.Clone();
            result.DtoName = this.DtoName;

            if(this.IncludeBaseEntity)
                result.BaseClassDtoName = this.BaseEntityDtoName;

            var selectedProperties = this.Properties
                .Where(p => p.IsSelected)
                .ToList();

            var relatedPropertiesWithSelection = this.Properties
                .Where(p => p.RelatedEntity != null)
                .Where(p => p.RelatedEntity.HasSelectionInSubtree())
                .ToList();

            var toRemoveFromMetadata = new List<Model.PropertyMetadata>();
            foreach(var x in result.Properties)
            {
                if (!selectedProperties.Concat(relatedPropertiesWithSelection).Any(p => p.Name == x.Name))
                {
                    toRemoveFromMetadata.Add(x);
                }
                else if(x.IsRelation && !x.IsCollection)
                {
                    var related = relatedPropertiesWithSelection
                        .Where(p => p.Name == x.Name)
                        .Select(p => p.RelatedEntity)
                        .FirstOrDefault();

                    x.RelationMetadata = related?.ConvertToMetadata();
                }
            }

            result.Properties.RemoveAll(p => toRemoveFromMetadata.Contains(p));

            return result;
        }

        public bool HasSelectionInSubtree()
        {
            return this.Properties.Any(p => p.IsSelected) || 
                this.Properties
                    .Where(p => p.RelatedEntity != null)
                    .Any(p => p.RelatedEntity.HasSelectionInSubtree());
        }
    }

    public class PropertyViewModel : ViewModelBase
    {
        private EntityViewModel _entityViewModel;

        public PropertyViewModel(EntityViewModel entityModel)
        {
            this._entityViewModel = entityModel;
        }

        public string Type { get; set; }
        public string Name { get; set; }

        public string NameFormatted => $"{Name} ({Type})";

        private bool _isSelected;
        public bool IsSelected
        {
            get
            {
                return this._isSelected;
            }
            set
            {
                if (value != this._isSelected)
                {
                    this._isSelected = value;
                    this.InvokePropertyChanged(nameof(IsSelected));

                    if(this._relatedEntity != null)
                    {
                        foreach (var prop in this._relatedEntity.Properties)
                            prop.IsSelected = value;
                    }
                }
            }
        }

        private bool _canSelect;
        public bool CanSelect
        {
            get
            {
                return this._canSelect;
            }
            set
            {
                if (value != this._canSelect)
                {
                    this._canSelect = value;
                    this.InvokePropertyChanged(nameof(CanSelect));
                }
            }
        }

        private EntityViewModel _relatedEntity;
        public EntityViewModel RelatedEntity
        {
            get
            {
                return this._relatedEntity;
            }
            set
            {
                if (value != this._relatedEntity)
                {
                    this._relatedEntity = value;
                    this.InvokePropertyChanged(nameof(RelatedEntity));
                }
            }
        }
    }
}
